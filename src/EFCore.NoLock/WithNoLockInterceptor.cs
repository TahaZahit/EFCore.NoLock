using System.Collections.Concurrent;
using System.Data.Common;
using Microsoft.EntityFrameworkCore.Diagnostics;
using Microsoft.SqlServer.TransactSql.ScriptDom;

namespace EFCore.NoLock;

/// <summary>
/// An Entity Framework Core interceptor that injects <c>WITH (NOLOCK)</c> hints into SQL Server queries.
/// </summary>
/// <remarks>
/// <para>
/// This interceptor listens for database commands generated by EF Core. If a command contains the specific tag 
/// added by the <c>WithNoLock()</c> extension method, it modifies the SQL syntax tree to append the 
/// <c>WITH (NOLOCK)</c> table hint to all accessed tables.
/// </para>
/// <para>
/// <b>Performance Note:</b> This class uses <see cref="Microsoft.SqlServer.TransactSql.ScriptDom"/> for safe SQL parsing 
/// and includes an internal cache mechanism to prevent re-parsing identical queries, ensuring minimal performance overhead.
/// </para>
/// </remarks>
public class WithNoLockInterceptor : DbCommandInterceptor
{
    private const string NoLockTag = "NOLOCK_MODE";
    private static readonly ConcurrentDictionary<string, string> SqlCache = new();

    /// <summary>
    /// Intercepts the execution of a <see cref="DbCommand"/> before the data reader is created.
    /// </summary>
    /// <remarks>
    /// This method inspects the command text. If the specific NOLOCK tag is detected, 
    /// it modifies the SQL statement to include 'WITH (NOLOCK)' hints before the command is sent to the database.
    /// </remarks>
    /// <param name="command">The <see cref="DbCommand"/> containing the SQL to be executed.</param>
    /// <param name="eventData">Contextual information about the command execution event.</param>
    /// <param name="result">The current result of the interception operation.</param>
    /// <returns>The result of the operation, potentially with modified SQL.</returns>
    public override InterceptionResult<DbDataReader> ReaderExecuting(
        DbCommand command,
        CommandEventData eventData,
        InterceptionResult<DbDataReader> result)
    {
        ApplyNoLockLogic(command);
        return base.ReaderExecuting(command, eventData, result);
    }

    /// <summary>
    /// Asynchronously intercepts the execution of a <see cref="DbCommand"/> before the data reader is created.
    /// </summary>
    /// <remarks>
    /// This method performs the same logic as <see cref="ReaderExecuting"/> but for asynchronous operations 
    /// (e.g., <c>ToListAsync</c>, <c>FirstOrDefaultAsync</c>). It ensures that the 'WITH (NOLOCK)' hint 
    /// is applied even in non-blocking calls.
    /// </remarks>
    /// <param name="command">The <see cref="DbCommand"/> containing the SQL to be executed.</param>
    /// <param name="eventData">Contextual information about the command execution event.</param>
    /// <param name="result">The current result of the interception operation.</param>
    /// <param name="cancellationToken">A token to monitor for cancellation requests.</param>
    /// <returns>A value task representing the asynchronous operation, returning the execution result.</returns>
    public override ValueTask<InterceptionResult<DbDataReader>> ReaderExecutingAsync(
        DbCommand command,
        CommandEventData eventData,
        InterceptionResult<DbDataReader> result,
        CancellationToken cancellationToken = default)
    {
        ApplyNoLockLogic(command);
        return base.ReaderExecutingAsync(command, eventData, result, cancellationToken);
    }

    private void ApplyNoLockLogic(DbCommand command)
    {
        if (!command.CommandText.Contains(NoLockTag))
            return;
        var newSql = SqlCache.GetOrAdd(command.CommandText, TransformSql);
        command.CommandText = newSql;
    }

    private static string TransformSql(string originalSql)
    {
        using var reader = new StringReader(originalSql);

        var parser = new TSql170Parser(true);
        var fragment = parser.Parse(reader, out var errors);

        if (errors.Count > 0)
        {
            return originalSql;
        }

        var visitor = new WithNoLockVisitor();
        fragment.Accept(visitor);

        var generator = new Sql170ScriptGenerator(new SqlScriptGeneratorOptions
        {
            KeywordCasing = KeywordCasing.Uppercase,
            IncludeSemicolons = true,
            AlignClauseBodies = false
        });

        generator.GenerateScript(fragment, out var transformedSql);

        return transformedSql;
    }
}